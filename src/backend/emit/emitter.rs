//! DTAL Text Emitter Implementation
//!
//! This module emits DTAL programs as text files with type annotations.
//! The format is human-readable and includes type state information
//! for verification purposes.

use crate::backend::dtal::instr::{BinaryOp, CmpOp, DtalBlock, DtalFunction, DtalInstr, DtalProgram};
use crate::backend::dtal::regs::Reg;
use crate::backend::dtal::Constraint;
use crate::common::types::IType;
use std::fmt::Write;

/// Emit a DTAL program as text
pub fn emit_program<'src>(program: &DtalProgram<'src>) -> String {
    let mut output = String::new();

    writeln!(output, "; DTAL Program").unwrap();
    writeln!(output, "; Generated by Veritas Compiler").unwrap();
    writeln!(output).unwrap();

    for func in &program.functions {
        emit_function(&mut output, func);
        writeln!(output).unwrap();
    }

    output
}

/// Emit a DTAL function
fn emit_function<'src>(output: &mut String, func: &DtalFunction<'src>) {
    // Function header
    writeln!(output, ".function {}", func.name).unwrap();

    // Parameters
    if !func.params.is_empty() {
        write!(output, ".params {{").unwrap();
        for (i, (reg, ty)) in func.params.iter().enumerate() {
            if i > 0 {
                write!(output, ", ").unwrap();
            }
            write!(output, "{}: {}", emit_reg(reg), emit_type(ty)).unwrap();
        }
        writeln!(output, "}}").unwrap();
    }

    // Return type
    writeln!(output, ".returns {}", emit_type(&func.return_type)).unwrap();

    // Precondition
    if let Some(ref pre) = func.precondition {
        writeln!(output, ".precondition {}", emit_constraint(pre)).unwrap();
    }

    writeln!(output).unwrap();

    // Entry point label
    writeln!(output, "{}:", func.name).unwrap();

    // Blocks
    for block in &func.blocks {
        emit_block(output, block);
    }
}

/// Emit a basic block
fn emit_block<'src>(output: &mut String, block: &DtalBlock<'src>) {
    // Block label
    writeln!(output, "{}:", block.label).unwrap();

    // Entry state comment (if non-empty)
    if !block.entry_state.register_types.is_empty() || !block.entry_state.constraints.is_empty() {
        writeln!(output, "    ; Entry state:").unwrap();
        for (reg, ty) in &block.entry_state.register_types {
            writeln!(output, "    ;   {}: {}", emit_reg(reg), emit_type(ty)).unwrap();
        }
        for constraint in &block.entry_state.constraints {
            writeln!(output, "    ;   assume {}", emit_constraint(constraint)).unwrap();
        }
    }

    // Instructions
    for instr in &block.instructions {
        emit_instruction(output, instr);
    }
}

/// Emit a single instruction
fn emit_instruction<'src>(output: &mut String, instr: &DtalInstr<'src>) {
    match instr {
        DtalInstr::MovImm { dst, imm, ty } => {
            writeln!(
                output,
                "    mov {}, {}    ; {}",
                emit_reg(dst),
                imm,
                emit_type(ty)
            )
            .unwrap();
        }

        DtalInstr::MovReg { dst, src, ty } => {
            writeln!(
                output,
                "    mov {}, {}    ; {}",
                emit_reg(dst),
                emit_reg(src),
                emit_type(ty)
            )
            .unwrap();
        }

        DtalInstr::Load { dst, base, offset, ty } => {
            writeln!(
                output,
                "    load {}, [{} + {}]    ; {}",
                emit_reg(dst),
                emit_reg(base),
                emit_reg(offset),
                emit_type(ty)
            )
            .unwrap();
        }

        DtalInstr::Store { base, offset, src } => {
            writeln!(
                output,
                "    store [{} + {}], {}",
                emit_reg(base),
                emit_reg(offset),
                emit_reg(src)
            )
            .unwrap();
        }

        DtalInstr::BinOp { op, dst, lhs, rhs, ty } => {
            writeln!(
                output,
                "    {} {}, {}, {}    ; {}",
                emit_binop(op),
                emit_reg(dst),
                emit_reg(lhs),
                emit_reg(rhs),
                emit_type(ty)
            )
            .unwrap();
        }

        DtalInstr::AddImm { dst, src, imm, ty } => {
            writeln!(
                output,
                "    addi {}, {}, {}    ; {}",
                emit_reg(dst),
                emit_reg(src),
                imm,
                emit_type(ty)
            )
            .unwrap();
        }

        DtalInstr::Cmp { lhs, rhs } => {
            writeln!(output, "    cmp {}, {}", emit_reg(lhs), emit_reg(rhs)).unwrap();
        }

        DtalInstr::CmpImm { lhs, imm } => {
            writeln!(output, "    cmp {}, {}", emit_reg(lhs), imm).unwrap();
        }

        DtalInstr::Not { dst, src, ty } => {
            writeln!(
                output,
                "    not {}, {}    ; {}",
                emit_reg(dst),
                emit_reg(src),
                emit_type(ty)
            )
            .unwrap();
        }

        DtalInstr::Jmp { target } => {
            writeln!(output, "    jmp {}", target).unwrap();
        }

        DtalInstr::Branch { cond, target } => {
            writeln!(output, "    b{} {}", emit_cmpop(cond), target).unwrap();
        }

        DtalInstr::Call { target } => {
            writeln!(output, "    call {}", target).unwrap();
        }

        DtalInstr::Ret => {
            writeln!(output, "    ret").unwrap();
        }

        DtalInstr::Push { src, ty } => {
            writeln!(output, "    push {}    ; {}", emit_reg(src), emit_type(ty)).unwrap();
        }

        DtalInstr::Pop { dst, ty } => {
            writeln!(output, "    pop {}    ; {}", emit_reg(dst), emit_type(ty)).unwrap();
        }

        DtalInstr::Alloca { dst, size, ty } => {
            writeln!(
                output,
                "    alloca {}, {}    ; {}",
                emit_reg(dst),
                size,
                emit_type(ty)
            )
            .unwrap();
        }

        DtalInstr::TypeAnnotation { reg, ty } => {
            writeln!(output, "    ; type {}: {}", emit_reg(reg), emit_type(ty)).unwrap();
        }

        DtalInstr::ConstraintAssume { constraint } => {
            writeln!(output, "    ; assume {}", emit_constraint(constraint)).unwrap();
        }

        DtalInstr::ConstraintAssert { constraint, msg } => {
            writeln!(
                output,
                "    ; assert {} ; {}",
                emit_constraint(constraint),
                msg
            )
            .unwrap();
        }
    }
}

/// Emit a register
fn emit_reg(reg: &Reg) -> String {
    match reg {
        Reg::Virtual(vreg) => format!("v{}", vreg.0),
        Reg::Physical(preg) => format!("{:?}", preg).to_lowercase(),
    }
}

/// Emit a binary operation
fn emit_binop(op: &BinaryOp) -> &'static str {
    match op {
        BinaryOp::Add => "add",
        BinaryOp::Sub => "sub",
        BinaryOp::Mul => "mul",
        BinaryOp::And => "and",
        BinaryOp::Or => "or",
    }
}

/// Emit a comparison operation
fn emit_cmpop(op: &CmpOp) -> &'static str {
    match op {
        CmpOp::Eq => "eq",
        CmpOp::Ne => "ne",
        CmpOp::Lt => "lt",
        CmpOp::Le => "le",
        CmpOp::Gt => "gt",
        CmpOp::Ge => "ge",
    }
}

/// Emit a type
fn emit_type<'src>(ty: &IType<'src>) -> String {
    match ty {
        IType::Unit => "unit".to_string(),
        IType::Int => "int".to_string(),
        IType::Bool => "bool".to_string(),
        IType::Array { element_type, size } => {
            format!("[{}; {}]", emit_type(element_type), size)
        }
        IType::Ref(inner) => format!("&{}", emit_type(inner)),
        IType::RefMut(inner) => format!("&mut {}", emit_type(inner)),
        IType::SingletonInt(val) => format!("int({})", val),
        IType::RefinedInt { base: _, prop } => {
            format!("{{a: int | {} }}", prop.var)
        }
        IType::Master(inner) => format!("master({})", emit_type(inner)),
    }
}

/// Emit a constraint
fn emit_constraint(constraint: &Constraint) -> String {
    use crate::backend::dtal::IndexExpr;

    fn emit_index_expr(e: &IndexExpr) -> String {
        match e {
            IndexExpr::Const(n) => n.to_string(),
            IndexExpr::Var(name) => name.clone(),
            IndexExpr::Add(l, r) => format!("({} + {})", emit_index_expr(l), emit_index_expr(r)),
            IndexExpr::Sub(l, r) => format!("({} - {})", emit_index_expr(l), emit_index_expr(r)),
            IndexExpr::Mul(l, r) => format!("({} * {})", emit_index_expr(l), emit_index_expr(r)),
        }
    }

    match constraint {
        Constraint::True => "true".to_string(),
        Constraint::False => "false".to_string(),
        Constraint::Eq(l, r) => format!("{} == {}", emit_index_expr(l), emit_index_expr(r)),
        Constraint::Lt(l, r) => format!("{} < {}", emit_index_expr(l), emit_index_expr(r)),
        Constraint::Le(l, r) => format!("{} <= {}", emit_index_expr(l), emit_index_expr(r)),
        Constraint::Gt(l, r) => format!("{} > {}", emit_index_expr(l), emit_index_expr(r)),
        Constraint::Ge(l, r) => format!("{} >= {}", emit_index_expr(l), emit_index_expr(r)),
        Constraint::Ne(l, r) => format!("{} != {}", emit_index_expr(l), emit_index_expr(r)),
        Constraint::And(l, r) => format!("({} && {})", emit_constraint(l), emit_constraint(r)),
        Constraint::Or(l, r) => format!("({} || {})", emit_constraint(l), emit_constraint(r)),
        Constraint::Not(c) => format!("!{}", emit_constraint(c)),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::backend::dtal::instr::TypeState;
    use crate::backend::dtal::VirtualReg;

    #[test]
    fn test_emit_simple_function() {
        let func = DtalFunction {
            name: "test".to_string(),
            params: vec![(Reg::Virtual(VirtualReg(0)), IType::Int)],
            return_type: IType::Int,
            precondition: None,
            blocks: vec![DtalBlock {
                label: ".test_bb0".to_string(),
                entry_state: TypeState::new(),
                instructions: vec![
                    DtalInstr::MovImm {
                        dst: Reg::Virtual(VirtualReg(1)),
                        imm: 42,
                        ty: IType::Int,
                    },
                    DtalInstr::Ret,
                ],
            }],
        };

        let program = DtalProgram {
            functions: vec![func],
        };

        let output = emit_program(&program);
        assert!(output.contains(".function test"));
        assert!(output.contains("mov v1, 42"));
        assert!(output.contains("ret"));
    }
}
